---
title: "Binding density primer batch"
output: html_notebook
---

```{r, eval=F}
library(parallel)
source("~/HexamerBias/rscripts/hexamer_sequence_functions.r")
```

We want to test how binding density changes for a different set of primers.

```{r}
prob.combos <- hexamerMatrix(stepSize = 0.1)
nrow(prob.combos)
```

Using `d3r.keqs` computed in `eps_and_Keq_estimation_final.Rmd`
```{r}
load("~/AvOwork/rdata/D3R_pt.RData")

d3r.pred.cov <- predict.coverage(d3r.keqs, eps.d3r)

d3r.dens <- d3r.pred.cov %>%
  mutate(binding.dens = pred.cov/abundance) 

dens <- d3r.dens %>%
  dplyr::select(template,binding.dens) 

```

Making density explanatory figure
```{r}
seq<- 'AATGCATGGATTGGTTTACGCATGCATGACTGTTCACACCTGAACAGGGTTTACGCATGGGAATACTGCAAATGCATGGATTGGTTTACGCATGCATGACTGTTCATTTACGCATGGGCTGACTGTTTTTCAGCACACAACACACCTGAACAGGGCTAGCTCGGGGTG'

l <- 20
fig.df <- data.frame(template=sapply(1:(nchar(seq)-6), function(i) substr(seq,i,i+5)) ) %>%
  inner_join(., dens) %>%
  mutate(n=1:n()) %>%
  mutate(tot.dens=rollsumr(binding.dens, k=l, fill=0)) 

# cols <- scico(length(unique(fig.df$template)), palette='berlin')
# names(cols) <- unique(fig.df$template)


p1 <- fig.df %>%  
  ggplot(., aes(n, binding.dens, fill=template)) + 
  geom_bar(stat='identity',alpha=0.7, color='black') +
  theme_classic() +
  ylab('Binding density') + xlab("Genomic coordinate") +
  guides(fill='none') +
  # geom_segment(x=which.max(fig.df$binding.dens), xend=which.max(fig.df$binding.dens)+10, y=max(fig.df$binding.dens), yend=max(fig.df$binding.dens))
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_text(size=16))

p2 <- fig.df %>%  
  ggplot(., aes(xmin=n, ymin=0, fill=template)) + 
  # geom_bar(stat='identity',alpha=0.7, width=10, position='dodge', color='black') +
  geom_rect(aes(xmax=n+l, ymax=binding.dens), alpha=0.7, color='black') +
  theme_classic() +
  ylab('Binding density') + xlab("Genomic coordinate") +
  guides(fill='none') +
  # geom_segment(x=1, xend=2, y=2, yend=3)
  geom_segment(aes(x=which.max(fig.df$binding.dens), xend=which.max(fig.df$binding.dens)+l, y=max(fig.df$binding.dens)+0.00008, yend=max(fig.df$binding.dens)+0.00008),  size=0.35) +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_text(size=16))

p3 <- fig.df %>%  
  ggplot(., aes(n, tot.dens)) + 
  geom_area(fill='grey', alpha=0.7, color='black') +
  theme_classic() +
  ylab('Predicted coverage') + xlab("Genomic coordinate") +
  guides(fill='none') +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_text(size=16)) 

p1
p2
p3

p1 + ggsave("~/AvOwork/useful_figs/dens_1_new.pdf")
p2 + ggsave("~/AvOwork/useful_figs/dens_2.pdf")
p3 + ggsave("~/AvOwork/useful_figs/dens_3.pdf")
```

### Maximize CpGs covered

To maximize the number of CpGs covered I have to enrich for hexamers that contain a CG and deplete the rest.

```{r}
hexs <- all.hexamers()
# hexs[which(grepl(hexs, pattern = "CG"))]

fc <- as.data.frame(hexs) %>%
  mutate(fc=ifelse(grepl(hexs, pattern = "CG"), 1, -1)) %>%
  rename(template=hexs)

compute.enrichment.score <- function(dens.df, fc.df){
  # dens.df <- pred.cov.df %>%
  #   mutate(binding.dens = pred.cov/abundance) 
  enrichment.score <- dens.df %>%
    inner_join(., fc, by="template") %>%
    mutate(dens.fc=binding.dens*fc) %>%
    summarise(score=sum(dens.fc)) %>%
    .$score
  return(enrichment.score)
  }

```

Predict coverage for different primer batches
```{r, warning=F}
test.combos <- prob.combos[which(prob.combos['pC']!=0 & prob.combos['pG']!=0),]
l.test.combos <- lapply(seq_len(nrow(test.combos)), function(i) test.combos[i,])

density.combo <- function(prob.vec, keqs.df=d3r.keqs, eps=epsilon.d3r){
  b.probs <- batch.prob.uniform(hexs=all.hexamers(), nuc.probs = prob.vec)
  pred.cov.b <- predict.coverage(keqs.df, eps, prob = b.probs)
  dens.df <- pred.cov.b %>%
    mutate(binding.dens = pred.cov/abundance)  %>% 
    dplyr::select(template, binding.dens)
  colnames(dens.df)[2] <- do.call(paste,c('dens',prob.vec, sep='_'))
  return(dens.df)
}

test <- density.combo(l.test.combos[[2]])


test.combo.density <- mclapply(sample(l.test.combos, 4), density.combo, mc.cores = 4)
func <- function(...){
  df1 = list(...)[[1]]
  df2 = list(...)[[2]]
  col1 = colnames(df1)[1]
  col2 = colnames(df2)[1]
  xxx = left_join(..., by = setNames(col2,col1))
  return(xxx)
}
dens.table <- Reduce( func, test.combo.density)

score <- unlist(lapply(test.combo.density, compute.enrichment.score, fc.df=fc))
```

Load CpG island FC hexamer enrichment
```{r}
cgi.fc <- read.csv("~/mnt/edann/hexamers/annotations_bed/CpGislands_srt_mm10.kmersFC.csv", header=F, col.names = c("template", "fc"))
cgi.fc
compute.enrichment.score(test, cgi.fc)
```

```{r}
load('~/mnt/edann/primer_combos_density.RData')

prova <- map(column_to_rownames(dens.table, var='template'), function(x) data.frame(template=dens.table$template, binding.dens=x))
scores <- map_dbl(prova, compute.enrichment.score, fc.df=cgi.fc)
compute.enrichment.score(dens.table[1:5], cgi.fc)
```

```{r}
dens.table %>% 
  select(template, dens_0_0.3_0.1_0.6) %>%
  filter(dens_0_0.3_0.1_0.6!=0) %>%
  inner_join(., cgi.fc)

dens.table %>% inner_join(select(d3r.keqs, template, abundance))

```

Save best hits for artificial coverage prediction
```{r}
pr2 <- map(prova, function(x) x %>% inner_join(., distinct(select(d3r.keqs, template, abundance)), by='template') %>% mutate(exp=binding.dens*abundance) %>% select(template, exp))

for (name in names(head(sort(scores, decreasing = F)))) {
  df <- pr2[name][[1]] %>% full_join(select(cele.df, template)) %>% mutate(exp=ifelse(is.na(exp), 0, exp))
  write.csv(df, file= paste0("~/AvOwork/D3R_", name, "_predcoverage.csv"), row.names = F, col.names = T, quote = F )
}

```